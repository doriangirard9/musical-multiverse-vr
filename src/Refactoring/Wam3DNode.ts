import * as B from "@babylonjs/core";
import { IAudioNodeConfig} from "./types.ts";
import {Scene} from "@babylonjs/core";
import { controls, WamGUIGenerator, WAMGuiInitCode } from "wam3dgenerator";
import { AudioNode3D } from "./AudioNode3D.ts";
import { AudioNodeState } from "./network/types.ts";
import { WamNode } from "@webaudiomodules/api";
import { App } from "../App.ts";
import { BoundingBox } from "./BoundingBox.ts";
import { DragParamNodeComp } from "./node3d/instance/N3DParameterInstance.ts";
import { ConnectionNodeComp } from "./node3d/instance/N3DConnectableInstance.ts";

/**
 * An AudioNode3D that create a WAM from a json code generated by
 * the wam 3d editor.
 * https://github.com/Jempasam/3d_wam_editor
 */
export class Wam3DEditorNode extends AudioNode3D {
    

    declare _output_audio_node: AudioNode|WamNode
    declare _input_audio_node: AudioNode|WamNode

    declare _wam_generator: WamGUIGenerator

    private disposables: {dispose():void}[] = []

    constructor(scene: Scene, audioCtx: AudioContext, id: string, readonly code: WAMGuiInitCode) {
        super(audioCtx, id);
    }

    public async instantiate(): Promise<void> {
        const [hostGroupId] = await App.getHostGroupId()

        const node3d = this
        const super_transform = new B.TransformNode("super_transform", this._scene)
        const transform = new B.TransformNode("root", this._scene)
        transform.parent = super_transform

        const highlightLayer = new B.HighlightLayer(`hl-connectors-${node3d.id}`, node3d._scene)

        this._wam_generator = await WamGUIGenerator.create_and_init(
            {
                babylonjs:{
                    root: transform,
                    defineAnInput(settings) {
                        const connection = new ConnectionNodeComp(
                            B.Color3.Green(), 'input',
                            settings.target, highlightLayer, node3d
                        )
                        node3d._input_audio_node = settings.node
                        node3d.inputMesh = settings.target[0] as B.Mesh
                        node3d.disposables.push(connection)
                    },
                    defineAnOutput(settings) {
                        const connection = new ConnectionNodeComp(
                            B.Color3.Red(), 'output',
                            settings.target, highlightLayer, node3d
                        )
                        node3d._output_audio_node = settings.node
                        node3d.outputMesh = settings.target[0] as B.Mesh
                        node3d.disposables.push(connection)
                    },
                    defineAnEventInput(settings) {
                        const connection = new ConnectionNodeComp(
                            B.Color3.Green(), 'inputMidi',
                            settings.target, highlightLayer, node3d
                        )
                        node3d._input_audio_node = settings.node
                        node3d.inputMeshMidi = settings.target[0] as B.Mesh
                        node3d.disposables.push(connection)
                    },
                    defineAnEventOutput(settings) {
                        const connection = new ConnectionNodeComp(
                            B.Color3.Red(), 'outputMidi',
                            settings.target, highlightLayer, node3d
                        )
                        node3d._output_audio_node = settings.node
                        node3d.outputMeshMidi = settings.target[0] as B.Mesh
                        node3d.disposables.push(connection)
                    },
                    defineField(settings) {
                        const parameter = new DragParamNodeComp(
                            super_transform, settings.target, highlightLayer,
                            settings.getName.bind(settings),
                            settings.getValue.bind(settings),
                            settings.setValue.bind(settings),
                            settings.getStepCount.bind(settings),
                            settings.stringify.bind(settings),
                        )
                        node3d.disposables.push(parameter)
                    },
                    defineDraggableField(){}
                }
            },
            this.code, controls, this._audioCtx, hostGroupId
        )
        

        const size_factor = .25/this._wam_generator.calculateAverageControlSize()
        transform!!.scaling.setAll(size_factor)
        
        const boundingBox = this._wam_generator.pad_node!! .getHierarchyBoundingVectors()
        const boundingblock = B.MeshBuilder.CreateBox('box', {
            width: boundingBox.min.x - boundingBox.max.x,
            height: boundingBox.min.y - boundingBox.max.y,
            depth: boundingBox.min.z - boundingBox.max.z,
        }, this._scene)
        boundingblock.isVisible = false
        super_transform.parent = boundingblock
        this.baseMesh = boundingblock

        this._utilityLayer = new B.UtilityLayerRenderer(this._scene)
        this._rotationGizmo = new B.RotationGizmo(this._utilityLayer)

        const bo = new BoundingBox(this, this._scene, this.id, this._app)
        this.boundingBox = bo.boundingBox
        this.boundingBox.scaling.scaleInPlace(2)

        this._initActionManager()
    }

    public getAudioNode(): AudioNode {
        return this._input_audio_node
    }

    public async getState(): Promise<AudioNodeState> {
        // @ts-ignore
        return {
            id: this.id,
            kind: {} as IAudioNodeConfig,
            position: { x: this.boundingBox.position.x, y: this.boundingBox.position.y, z: this.boundingBox.position.z },
            rotation: { x: this.boundingBox.rotation.x, y: this.boundingBox.rotation.y, z: this.boundingBox.rotation.z },
            inputNodes: [],
            parameters: {}
        };
    }

    public delete() {
        super.delete()
        this._wam_generator.dispose()
        this.disposables.forEach(d => d.dispose())
        this.disposables = []
    }


}